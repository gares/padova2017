<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <link rel="stylesheet" href="jscoq/ui-external/bootstrap.min.css" />

<title>lesson1</title><script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML'> </script> <script type='text/javascript'> MathJax.Hub.Config({ 'HTML-CSS': { preferredFont: 'STIX' } }); </script>
<link rel="stylesheet" href="local.css" />
  </head>

<body>
  <div id="ide-wrapper" class="toggled">
  <div id="code-wrapper">
  <div id="document">

<div><textarea id='coq-ta-1'>
</textarea></div>
<div><p>
<div class='slide vfill'> 
<h1>
 L'assistente alla dimostrazione Coq
</h1>

<p>
<center><img src="https://coq.inria.fr/files/barron_logo.png"/></center>
<p>
<a href="https://coq.inria.fr/">Sito web di Coq</a>
<p>
<a href="http://www-sop.inria.fr/members/Enrico.Tassi/padova2017/">Sito web del mini corso</a>
http://www-sop.inria.fr/members/Enrico.Tassi/padova2017/
<p>
</div> <p>
<hr/>
 <p>
 <div class='slide vfill'> 
<h2>
 Coq: un assistente alla dimostrazione
</h2>

<p>
<ul class="doclist">
  <li> Cos'è un assistente alla dimostrazione?!

  </li>
<li> Coq è basato sulla (una variante) dell teoria dei
   tipi di Martin Löf

</li>
<li> Coq è utilizzato per
<ul class="doclist">
  <li> formalizzare matematica

  </li>
<li> verificare software

</li>
</ul>

</li>
</ul>
<p>
</div> <p>
<hr/>
 <p>
 <div class='slide vfill'> 
<h2>
 Chi sono io?
</h2>

<p>
<ul class="doclist">
  <li> <a href="http://www-sop.inria.fr/members/Enrico.Tassi/">Enrico Tassi</a>

  </li>
<li> Sviluppatore Coq

</li>
<li> Ricercatore (implementazione PA e loro utilizzo)

</li>
</ul>
<p>
</div> <p>
<hr/>
 <p>
 <div class='slide vfill'> 
<h2>
 Obiettivi del mini corso
</h2>

<p>
<ul class="doclist">
  <li> Vedere una applicazione pratica della teoria dei tipi

  </li>
<li> Introduzione a un assistente alla dimostrazione
    (proof assistant, interactive theorem prover)

</li>
</ul>
<p>
</div>
<hr/>
 <p>
 <div class='slide vfill'>  
<h2>
 Piano di battaglia
</h2>

<p>
<ul class="doclist">
  <li> <a href="http://www-sop.inria.fr/members/Enrico.Tassi/padova2017/lesson1.html">lezione 1</a>: il linguaggio dei programmi

  </li>
<li> <a href="http://www-sop.inria.fr/members/Enrico.Tassi/padova2017/lesson2.html">lezione 2</a>: il linguaggio della logica

</li>
<li> <a href="http://www-sop.inria.fr/members/Enrico.Tassi/padova2017/lesson3.html">lezione 3</a>: dimostrazioni per induzione

</li>
<li> <a href="http://www-sop.inria.fr/members/Enrico.Tassi/padova2017/lesson4.html">lezione 4</a>: il calcolo e la riflessione

</li>
</ul>
<p>
</div> <p>
<hr/>
 <p>
 <div class='slide vfill'>  
<h2>
 Lezione 1
</h2>

<p>
<ul class="doclist">
  <li> Programmazione in Coq
<ul class="doclist">
    <li> funzioni anonime e non

    </li>
  <li> calcolo

  </li>
  <li> tipi di dato algebrici

  </li>
  <li> pattern matching

  </li>
  <li> ricorsione

  </li>
  <li> tipi di dato polimorfi

  </li>
  <li> ordine superiore
<p>
  
  </li>
  </ul>
  
  </li>
<li> Esercizi

</li>
</ul>
<p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Funzioni
</h2>

<p>
<ul class="doclist">
  <li> Nota: anche se nat, + e 1 sono concetti definibili
  in Coq, l'ambiente iniziale non è vuoto ma contiene
  alcuni declarazioni (come i numeri naturali) utili
  a fare esempi

  </li>
</ul>
$$ 
f = x \mapsto x + 1
$$
$$
f : \mathcal{N} \to \mathcal{N}
$$
<p>
</div>
<div><textarea id='coq-ta-2'>

Check (fun (x : nat) => x + 1).

Definition f (x : nat) : nat :=
  x + 1.

Definition g (x : nat) (y : nat) : nat :=
  f x * y.

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Calcolo
</h2>

<p>
<ul class="doclist">
  <li> Prendiamo la funzione (il programma) f definito
   in precedenza

  </li>
</ul>
$$ 
f = x \mapsto x + 1 : \mathcal{N} \to \mathcal{N}
$$
<pre>
Definition f (x : nat) : nat :=
  x + 1 .
</pre>
<p>
<ul class="doclist">
  <li> Chiediamo a Coq di calcolare la forma canonica
   dei termini seguenti

  </li>
</ul>
</div>
<div><textarea id='coq-ta-3'>

Eval compute in 3 + 1.

Eval compute in (fun x => x + 1) 3.

Eval compute in f 3.

Eval compute in g 3 4.

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Tipi di dato algebrici
</h2>

<p>
<ul class="doclist">
  <li> Facciamo finta che i numeri naturali
   che abbiamo usato finora non sia disponibili
   e definiamoli noi

  </li>
</ul>
</div>
<div><textarea id='coq-ta-4'>

Module ProvaBoolNat.

Inductive bool := true | false.

</textarea></div>
<div><p>
true e false si chiamano costruttori, e
    corrispondono alle regole $$Tipo-I_n$$
    nelle note del corso </div>
<div><textarea id='coq-ta-5'>

Check true.

</textarea></div>
<div><p>
I numeri naturali à la Peano
<p>
    Nota: <em>O</em> è una o maiuscola, non la cifra zero </div>
<div><textarea id='coq-ta-6'>
Inductive nat := O | S (n : nat).

Check O.
Check S.

Check (S O).

</textarea></div>
<div><p>
Nota: esistono varie sintassi alternative per
    la dichiarazione di tipi di dato.
<p>
  Quella che abbiamo utilizzata è la più simile a quella
  usata nelle note del corso e anche nei linguaggi di
  programmazione.  Se chiediamo a Coq di stampare una
  dichiarazione di tipo con:
<p>
</div>
<div><textarea id='coq-ta-7'>

Print nat.

</textarea></div>
<div><p>
<pre>
Inductive nat :=
   O : nat
 | S : nat -> nat.
</pre>
</div>
<div><textarea id='coq-ta-8'>

End ProvaBoolNat.

</textarea></div>
<div><p>
Ora torniamo a utilizzare la dichiarazione standard di
    <em>nat</em> in quanto il sistema li stampa meglio (notazione decimale).
</div>
<div><textarea id='coq-ta-9'>

Print nat.
Check (S O).
Set Printing All.
Check (S O).
Unset Printing All.
Check (S O).

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Pattern matching
</h2>

<p>
<ul class="doclist">
  <li> In Coq l'eliminatore (chiamato <em>El</em> nelle note
   del corso) è fornito in <em>kit</em>:
<ul class="doclist">
    <li> il costrutto <em>match</em> fornisce l'analisi per casi

    </li>
  <li> il costrutto <em>Fixpoint</em> (in seguito) fornisce
     l'ipotesi induttiva

  </li>
  </ul>
  
  </li>
</ul>
<p>
</div>
<div><textarea id='coq-ta-10'>

Definition notb (b : bool) :=
  match b with
  | true => false
  | false => true
  end.

Eval compute in notb true.
Eval compute in notb false.

Definition andb (b1 : bool) (b2 : bool) :=
  match b1 with
  | true => b2
  | false => false
  end.

Eval compute in andb true true.
Eval compute in andb true false.

Definition predecessore (n : nat) : nat :=
  match n with
  | O => O
  | S p => p
  end.

</textarea></div>
<div><p>
<p>
  Note:
<p>
<ul class="doclist">
  <li> Ogni clausola del pattern matching è della forma
    <tt>| pattern => corpo </tt><p>
      dove pattern è un costruttore applicato a un numero
    di variabili appropriato
<p>
  
  </li>
<li> Tutti i costruttori del tipo di dato devono essere
    trattati da un pattern

</li>
<li> <em>p</em> è una variabile legata dal pattern matching
    e può essere utilizzata nel corpo della clausola

</li>
</ul>
  Esempio di esecuzione:
 <tt>
   match S (S O) with
   | O => O
   | S p => p
   end

   O    ==?== S (S O)  no, proviamo la prossima clausola
   S p  ==?== S (S O)  sì, p lega (S O)
 </tt><p>
<p>
<p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Ricorsione
</h2>

</div>
<div><textarea id='coq-ta-11'>

Fixpoint addn (n : nat) (m : nat) : nat :=
  match n with
  | O => m  (* 0 + m = m *)
  | S p => S (addn p m)   (* S p + m = S (p + m) *)
  end.

Eval compute in addn 2 4.

</textarea></div>
<div><p>
Esempio di esecuzione:
<pre>
  addn 2 4
  addn (S (S O)) 4
  S (addn (S O) 4)
  S (S (addn O 4))
  S (S 4)
  6
</pre>
<p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Tipi di dato polimorfi
</h2>

<p>
<ul class="doclist">
  <li> La coppia (a,b) dove a : A e b : B

  </li>
<li> La lista x1 :: .. :: xn dove x_i : A

</li>
</ul>
<p>
</div>
<div><textarea id='coq-ta-12'>

Inductive prod (A : Type) (B : Type) :=
  | pair (a : A) (b : B).

Check prod.
Check prod nat bool.
Check pair.

</textarea></div>
<div><p>
Nota: forall A B : Type, ci indica che il tipo
    pair è polimorfo, ovvero A e B possono essere rimpiazzati per
    un tipo di data </div>
<div><textarea id='coq-ta-13'>

Check pair nat bool.
Check pair nat bool 3 false.

</textarea></div>
<div><p>
Nota: come assegnare il tipo a una applicazione
<pre>
      addn : nat -> nat -> nat
      addn 3 : nat -> nat
      addn 3 4 : nat
</pre>
    Se il tipo è quantificato, allora il valore
    dell'argomento sostituisce la variabile in ciò
    che rimane
<pre>
      pair : forall A, forall B, A -> B -> prod A B
      pair nat : forall B, nat -> B -> prod nat B
      pair nat bool : nat -> bool -> prod nat bool
      pair nat bool 3 : bool -> prod nat bool
      pair nat bool 3 false : prod nat bool
</pre>
</div>
<div><textarea id='coq-ta-14'>

Definition fst (A : Type) (B : Type) (x : prod A B) : A :=
  match x with
  | pair _ _ x1 x2 => x1
  end.

Eval compute in fst nat bool (pair nat bool 3 false).

</textarea></div>
<div><p>
Argomenti impliciti (inferiti da Coq) </div>
<div><textarea id='coq-ta-15'>

Check pair _ _ 3 false.
Eval compute in fst _ _ (pair _ _ 3 false).

Arguments pair {_ _} a b.
Arguments fst {_ _} x.

Check pair 3 false.
Eval compute in fst (pair 3 false).

Definition snd (A : Type) (B : Type) (x : prod A B) : B :=
  match x with
  | pair x1 x2 => x2
  end.

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Liste
</h2>

<p>
</div>
<div><textarea id='coq-ta-16'>

Inductive list (A : Type) :=
  nil | cons (a : A) (tl : list A).

Arguments nil {_}.
Arguments cons {_} a tl.

Fixpoint length A (l : list A) : nat :=
  match l with
  | nil => 0
  | cons x xs => S (length A xs)
  end.

Arguments length {_} l.

Eval compute in length (cons 3 (cons 4 nil)).

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class="slide vfill">
<h2>
 Wrap up
</h2>

<p>
<ul class="doclist">
  <li> funzioni anonime: <tt>fun x : nat => x + 1</tt>

  </li>
<li> tipi di dato: <tt>Inductive nat := O | S (n : nat)</tt>

</li>
<li> pattern matching: <tt>match x with O => .. | S p => ..</tt>

</li>
<li> ricorsione: <tt>Fixpoint addn n m := ...</tt>

</li>
<li> polymorfismo: <tt>Inductive pair (A B : Type) := ..</tt>

</li>
<li> argomenti impliciti: <tt>Check pair 2 3</tt>

</li>
</ul>
 </div> <hr/>
 <p>
 <div class='slide'>
<h2>
 Esercizi
</h2>

<p>
</div>
<div><textarea id='coq-ta-17'>

Module Exercises.

(* Here you really need induction *)

Lemma odd_exp (m n : nat) : m = n.
Proof.
(* fill in *)
Admitted.

</textarea></div>
<div><p>
<p>

<button onclick="hide('sol1')">Solution</button>
<div id='sol1' class='solution'>
<pre>
elim: n => // n IHn.
rewrite expnS odd_mul IHn orbC.
move=> {IHn}.
by case: (odd m).
</pre>
</div>

</div>
<div><textarea id='coq-ta-18'>

End Exercises.

</textarea></div>
<div><p>
</div> </div>
<div><textarea id='coq-ta-19'>

(* ------------------------------------------------------ *)

</textarea></div>
<div><p>

<script>
alignWithTop = true;
current = 0;
slides = [];
function select_current() {
  for (var i = 0; i < slides.length; i++) {
    var s = document.getElementById('slideno' + i);
    if (i == current) {
      s.setAttribute('class','slideno selected');
    } else {
      s.setAttribute('class','slideno');
    }
  }	
}
function init_slides() {
  var toolbar = document.getElementById('panel-wrapper');
  if (toolbar) {
  var tools = document.createElement("div");
  var tprev = document.createElement("div");
  var tnext = document.createElement("div");
  tools.setAttribute('id','tools');
  tprev.setAttribute('id','prev');
  tprev.setAttribute('onclick','prev_slide();');
  tnext.setAttribute('id','next');
  tnext.setAttribute('onclick','next_slide();');
  toolbar.appendChild(tools);
  tools.appendChild(tprev);
  tools.appendChild(tnext);
  
  slides = document.getElementsByClassName('slide');
  for (var i = 0; i < slides.length; i++) {
    var s = document.createElement("div");
    s.setAttribute('id','slideno' + i);
    s.setAttribute('class','slideno');
    s.setAttribute('onclick','goto_slide('+ i +');');
    s.innerHTML = i;
    tools.appendChild(s);
  }
  select_current();
  } else {
  //retry later
  setTimeout(init_slides,100);	  
  }
}
function on_screen(rect) {
  return (
    rect.top >= 0 &&
    rect.top <= (window.innerHeight || document.documentElement.clientHeight)
  );
}
function update_scrolled(){
  for (var i = slides.length-1; i >= 0; i--) {
    var rect = slides[i].getBoundingClientRect();
      if (on_screen(rect)) {
        current = i;
        select_current();	
    }
  }
}
function goto_slide(n) {
  current = n;
  var element = slides[current];
  console.log(element);
  element.scrollIntoView(alignWithTop);
  select_current();
}
function next_slide() {
  current++;
  if (current >= slides.length) { current = slides.length - 1; }
  var element = slides[current];
  console.log(element);
  element.scrollIntoView(alignWithTop);
  select_current();
}
function prev_slide() {
  current--;
  if (current < 0) { current = 0; }
  var element = slides[current];
  element.scrollIntoView(alignWithTop);
  select_current();
}
function hide (element_id) {
  element = document.getElementById(element_id);
    if (element.style.display != 'block') {
      element.style.display = 'block';
    } else {
      element.style.display = 'none';
    }
}
window.onload = init_slides;
window.onscroll = update_scrolled;
</script>
 </div>
<div><textarea id='coq-ta-20'>
</textarea></div>
<script type="text/javascript">
 var coqdoc_ids = ['coq-ta-1',  'coq-ta-2',  'coq-ta-3',  'coq-ta-4', 
                  'coq-ta-5',  'coq-ta-6',  'coq-ta-7',  'coq-ta-8', 
                  'coq-ta-9',  'coq-ta-10',  'coq-ta-11',  'coq-ta-12', 
                  'coq-ta-13',  'coq-ta-14',  'coq-ta-15',  'coq-ta-16', 
                  'coq-ta-17',  'coq-ta-18',  'coq-ta-19',  'coq-ta-20'];
</script>
  </div> <!-- /#document     -->
  </div> <!-- /#code-wrapper -->
  </div> <!-- /#ide-wrapper  -->

  <script src="./jscoq/ui-js/jscoq-loader.js" type="text/javascript"></script>
  <script type="text/javascript">
    var coq;

    loadJsCoq('./jscoq/')
              .then(loadJs("./jscoq/ui-external/CodeMirror/addon/runmode/runmode"))
              .then(loadJs("./jscoq/ui-external/CodeMirror/addon/runmode/colorize"))
              .then( function () {
                  var coqInline = document.getElementsByClassName("inline-coq");
                  CodeMirror.colorize(coqInline); })
              .then( function () {
                  coq = new CoqManager (coqdoc_ids,
                                       { base_path: './jscoq/', init_pkgs: ['init'] }
                  );
              });
  </script>
</body>
</html>

