<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <link rel="stylesheet" href="jscoq/ui-external/bootstrap.min.css" />

<title>lesson4</title><script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML'> </script> <script type='text/javascript'> MathJax.Hub.Config({ 'HTML-CSS': { preferredFont: 'STIX' }, tex2jax: { inlineMath: [['XXX','XXX']] } }); </script>
<link rel="stylesheet" href="local.css" />
  </head>

<body>
  <div id="ide-wrapper" class="toggled">
  <div id="code-wrapper">
  <div id="document">

<div><textarea id='coq-ta-1'>
</textarea></div>
<div><p>
<div class='slide vfill'>  
<h2>
 Lezione 4
</h2>

<p>
<ul class="doclist">
  <li> Riflessione computazionale
<ul class="doclist">
    <li> idea

    </li>
  <li> normalizzazione nella segnatura di
     un monoide
<p>
  
  </li>
  </ul>
  
  </li>
<li> Applicazioni di Coq
<ul class="doclist">
  <li> un compilatore C verificato

  </li>
<li> un libreria di matematica organizzata
     come una libreria di programmi 
<p>

</li>
</ul>

</li>
<li> Esercizi

</li>
</ul>
<p>
</div> </div>
<div><textarea id='coq-ta-2'>

From mathcomp Require Import all_ssreflect.

</textarea></div>
<div><p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
  
</h2>

   Bello:
<p>
<ul class="doclist">
  <li> nella teoria dei tipi dimostrare <tt>2+3=3+2</tt> è facile,
     o meglio, la dimostrazione è <em>molto</em> corta <tt>apply: refl</tt>

  </li>
<li> tale dimostrazione non dipende dalla taglia delle espressioni
     coinvolte, ie rimane triviale anche per <tt>2+3+4+5=5+2+3+4</tt>

</li>
</ul>
   Meno bello:
<p>
<ul class="doclist">
  <li> il calcollo è completo su termini chiusi, se sono presenti
     variabili dobbiamo rgionare per induzione o riutilizzare lemmi
     dimostrati in precendenza, eg <tt>x + 0 = x</tt>

  </li>
<li> la taglia della dimostrazione dipende però dal numero di passi
     da fare, eg <tt>(x + 0) + 0 = x</tt> richiede 2 riscritture

</li>
</ul>
   Osservazione:
<p>
<ul class="doclist">
  <li> l'esecuzione di un programma <tt>p</tt> non richiede una prova
     <tt>p x = y</tt>

  </li>
<li> e non importa quanti <quote>passi</quote> di esecuzione <tt>p</tt> faccia
     la prova di <tt>p x = y</tt> è sempre <tt>refl</tt>

</li>
</ul>
   Idea: potremmo scrivere un programma che <quote>fa la dimostrazione</quote>
   (quando questa è ripetitiva).
<p>
   Per empio <tt>p</tt> potrebbe prendere una expressione in
   un monoide e metterla in forma normale, e.g.
<p>
     x + 0 + (y + 0) ----> x + y
<p>
   Iniziamo col dare una rappresentazione concreta (un dato
   induttivo) alle espressioni nel monoide.
<p>
 </div> </div>
<div><textarea id='coq-ta-3'>

Inductive Syntax A :=
  | Identity
  | Value (a : A)
  | Op (m1 : Syntax A) (m2 : Syntax A).

Arguments Identity {_}.
Arguments Value {_} a.
Arguments Op {_} m1 m2.

(* 3 + (0 + 2) *)
Definition example : Syntax nat := 
  (Op (Value 3) (Op Identity (Value 2))).

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Intepretazione
</h2>

<p>
  Il termine <tt>x + (0 + y)</tt> è di tipo <tt>nat</tt> ed è
  un termine che potremmo trovare in un goal.
  La sua rappresentazione sintattica <tt>Op (Value x) ..</tt>
  non ha tipo <tt>nat</tt>, anche se rappresenta un termine
  di tale tipo.
<p>
  Scriviamo una funziona che interpreta una
  espressione sintattica in un monoide
<p>
 </div>
<div><textarea id='coq-ta-4'>

Fixpoint interp {A} op id (m : Syntax A) :=
  match m with
  | Identity => id
  | Value x => x
  | Op l r => op (interp op id l) (interp op id r)
  end.

Eval compute -[addn] in interp addn 0 example.

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Normalizzazione
</h2>

<p>
     Op Identity x --> x
     Op x Identity --> x
     Op x (Op y z) --> Op (Op x y) z
<p>
</div>
<div><textarea id='coq-ta-5'>

Fixpoint norm {A} (m : Syntax A) :=
  match m with
  | Identity => Identity
  | Value x => Value x
  | Op l r =>
      let l := norm l in
      let r := norm r in
      match l, r with
      | Identity, _ => r
      | _, Identity => l
      | _, Op a b => Op (Op l a) b
      | _, _ => Op l r
      end
   end.

Eval compute -[addn] in interp addn 0 (norm example).

Lemma norm_ok_example :
  interp addn 0 example = interp addn 0 (norm example).
Proof.
apply: (erefl (3+2)).
Qed.

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Correttezza dell'algoritmo di normalizzazione
</h2>
</div>
<div><textarea id='coq-ta-6'>

Lemma norm_ok {A op id} :
  (forall a b c, op a (op b c) = op (op a b) c) ->
  (forall a, op id a = a) ->
  (forall a, op a id = a) ->
  forall (m : Syntax A), 
    interp op id m = interp op id (norm m).
Proof.
move=> opA idL idR m.
elim: m => //= e1 -> e2 ->.
by case: (norm e1); case: (norm e2) => /=.
Qed.

Lemma test x y :
  x + (y + 0) + 0 = x + y.
Proof.
pose s := Op (Op (Value x) (Op (Value y) Identity)) Identity.
change (interp addn 0 s = x+y).
rewrite (norm_ok addnA add0n addn0).
apply: erefl.
Qed.

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Reificazione
</h2>

<p>
  Non è una funzione delle teoria dei tipi:
<p>
<ul class="doclist">
  <li> la teoria quozienta i termini wrt il calcolo

  </li>
<li> <tt>1 + 1</tt> e <tt>2</tt> sono indistinguibili

</li>
<li> ma <tt>Op (Value 1) (Value 1)</tt> e <tt>Value 2</tt> sono
    ben diversi!

</li>
<li> quello che è preservato è il significato (interpretazione)

</li>
</ul>
  Soluzione: la funzione di reificazione la scriviamo un
  linguaggio che non è la teoria dei tipi ;-)
<p>
  Fortna: non ci interessa dimostrarla corretta, basta
  che lo sia in pratica.
<p>
</div>
<div><textarea id='coq-ta-7'>

Ltac quote t :=
  match t with
  | (?a + ?b) =>
        let x := quote a in
        let y := quote b in
        uconstr:(Op x y)
  | 0 => uconstr:(Identity)
  | ?x => uconstr:(Value x)
  end.

Ltac monoid :=
  match goal with
  |- ?a = ?b =>
      let x := quote a in
      let y := quote b in 
      change (interp addn 0 x = interp addn 0 y);
      rewrite [interp addn 0 x](norm_ok addnA add0n addn0);
      rewrite [interp addn 0 y](norm_ok addnA add0n addn0);
      compute -[addn]
  end.

Lemma test2 x y :
  x + (y + 0) + 0 = 0 + x + y.
Proof.
monoid.
apply: erefl.
Qed.

</textarea></div>
<div><p>
</div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Applicazione: Compilatore certificato CompCert
</h2>

<p>
 </div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Applicazione: Verfica di prove di matematica
</h2>

<p>
 </div> <p>
<hr/>
 <p>
 <div class='slide'> 
<h2>
 Esercizio:
</h2>

<p>
   aggiungere un elemento assorbente
   al monoide (sintassi, interpretazione, normalizzazione
   e prova di correttezza) 
<p>
<p>

<button onclick="hide('sol11')">Soluzione</button>
<div id='sol11' class='solution'>
<pre>


Inductive Syntax A :=
  | Identity
  | Annihilator
  | Value (a : A)
  | Op (m1 : Syntax A) (m2 : Syntax A).

Arguments Value {_} a.
Arguments Op {_} m1 m2.
Arguments Identity {_}.
Arguments Annihilator {_}.

Fixpoint interp {A} op id abs (m : Syntax A) :=
  match m with
  | Identity => id
  | Annihilator => abs
  | Value x => x
  | Op l r => op (interp op id abs l) (interp op id abs r)
  end.

Fixpoint norm {A} (m : Syntax A) :=
  match m with
  | Identity => Identity
  | Annihilator => Annihilator
  | Value x => Value x
  | Op l r =>
      let l := norm l in
      let r := norm r in
      match l, r with
      | Annihilator, _ => Annihilator
      | _, Annihilator => Annihilator
      | Identity, _ => r
      | _, Identity => l
      | _, Op a b => Op (Op l a) b
      | _, _ => Op l r
      end
   end.

Lemma norm_ok {A op id abs} :
  (forall a b c, op a (op b c) = op (op a b) c) ->
  (forall a, op id a = a) ->
  (forall a, op a id = a) ->
  (forall a, op abs a = abs) ->
  (forall a, op a abs = abs) ->
  forall (m : Syntax A), 
    interp op id abs m = interp op id abs (norm m).
Proof.
move=> opA idL idR abdL absR m.
elim: m => //= e1 -> e2 ->.
case: (norm e1); case: (norm e2) => //=.
Qed.
</pre>
</div>

<p>
 </div> <p>
<p>

<script>
alignWithTop = true;
current = 0;
slides = [];
function select_current() {
  for (var i = 0; i < slides.length; i++) {
    var s = document.getElementById('slideno' + i);
    if (i == current) {
      s.setAttribute('class','slideno selected');
    } else {
      s.setAttribute('class','slideno');
    }
  }	
}
function init_slides() {
  var toolbar = document.getElementById('panel-wrapper');
  if (toolbar) {
  var tools = document.createElement("div");
  var tprev = document.createElement("div");
  var tnext = document.createElement("div");
  tools.setAttribute('id','tools');
  tprev.setAttribute('id','prev');
  tprev.setAttribute('onclick','prev_slide();');
  tnext.setAttribute('id','next');
  tnext.setAttribute('onclick','next_slide();');
  toolbar.appendChild(tools);
  tools.appendChild(tprev);
  tools.appendChild(tnext);
  
  slides = document.getElementsByClassName('slide');
  for (var i = 0; i < slides.length; i++) {
    var s = document.createElement("div");
    s.setAttribute('id','slideno' + i);
    s.setAttribute('class','slideno');
    s.setAttribute('onclick','goto_slide('+ i +');');
    s.innerHTML = i;
    tools.appendChild(s);
  }
  select_current();
  } else {
  //retry later
  setTimeout(init_slides,100);	  
  }
}
function on_screen(rect) {
  return (
    rect.top >= 0 &&
    rect.top <= (window.innerHeight || document.documentElement.clientHeight)
  );
}
function update_scrolled(){
  for (var i = slides.length-1; i >= 0; i--) {
    var rect = slides[i].getBoundingClientRect();
      if (on_screen(rect)) {
        current = i;
        select_current();	
    }
  }
}
function goto_slide(n) {
  current = n;
  var element = slides[current];
  console.log(element);
  element.scrollIntoView(alignWithTop);
  select_current();
}
function next_slide() {
  current++;
  if (current >= slides.length) { current = slides.length - 1; }
  var element = slides[current];
  console.log(element);
  element.scrollIntoView(alignWithTop);
  select_current();
}
function prev_slide() {
  current--;
  if (current < 0) { current = 0; }
  var element = slides[current];
  element.scrollIntoView(alignWithTop);
  select_current();
}
function hide (element_id) {
  element = document.getElementById(element_id);
    if (element.style.display != 'block') {
      element.style.display = 'block';
    } else {
      element.style.display = 'none';
    }
}
window.onload = init_slides;
window.onscroll = update_scrolled;
</script>
 </div>
<div><textarea id='coq-ta-8'>
</textarea></div>
<script type="text/javascript">
 var coqdoc_ids = ['coq-ta-1',  'coq-ta-2',  'coq-ta-3',  'coq-ta-4', 
                  'coq-ta-5',  'coq-ta-6',  'coq-ta-7',  'coq-ta-8'];
</script>
  </div> <!-- /#document     -->
  </div> <!-- /#code-wrapper -->
  </div> <!-- /#ide-wrapper  -->

  <script src="./jscoq/ui-js/jscoq-loader.js" type="text/javascript"></script>
  <script type="text/javascript">
    var coq;

    loadJsCoq('./jscoq/')
              .then(loadJs("./jscoq/ui-external/CodeMirror/addon/runmode/runmode"))
              .then(loadJs("./jscoq/ui-external/CodeMirror/addon/runmode/colorize"))
              .then( function () {
                  var coqInline = document.getElementsByClassName("inline-coq");
                  CodeMirror.colorize(coqInline); })
              .then( function () {
                  coq = new CoqManager (coqdoc_ids,
                                       { base_path: './jscoq/', init_pkgs: ['init'] }
                  );
              });
  </script>
</body>
</html>

